### Stage

[Documentation](../README.md#documentation)

A `Stage` represents a single building block in the processing logic of a `Pipeline`.
It provides a set of `Callable`s that are used in a `Pipeline.run`.
Their order of execution is given by `primer` > `action` > `export` > `status` > `message`.
The arguments that are passed into those `Callable`s vary by `Callable` and execution context.
Below a list of all keywords that can occur is given (most `Callable`s receive only a subset of these):
* all kwargs given to `Pipeline.run` or exported during execution are forwarded (note that this makes the following arguments reserved words in this context)
* **out**: a persistent data-object that is passed through the entire `Pipeline`; its initial value is generated by the `Pipeline`'s `initialize_output`
* **primer**: output of `Stage.primer`
* **status**: output of `Stage.status`
* **count**: index of `Stage` in execution of `Pipeline`

#### Stage properties
`Stage`s accept a number of different (optional) arguments that are mostly `Callable`s to be used by a `Pipeline` during execution.
* **requires**: requirements for `Stage`-execution being either `None` (always run this `Stage`) or a dictionary with pairs of references to a `Stage` and the required status (uses most recent evaluation);

  key types are either `StageRef`, `str` (identifier of a `Stage` in the context of a `Pipeline`), or `int` (relative index in `Pipeline` stage arrangement);

  values are either an integer or a `Callable` taking the status as an argument and returning a `bool` (if it evaluates to `True`, the `Stage`-requirement is met)

  ```
  >>> from data_plumber import Pipeline, Stage, Previous
  >>> Pipeline(
  ...   Stage(
  ...     message=lambda **kwargs: "first stage",
  ...     status=lambda **kwargs: 1
  ...   ),
  ...   Stage(
  ...     requires={Previous: 0},
  ...     message=lambda **kwargs: "second stage"
  ...   ),
  ... ).run().last_message
  'first stage'
  ```

* **primer**: `Callable` for pre-processing data

  (kwargs: `out`, `count`)

  ```
  >>> Pipeline(
  ...   Stage(
  ...     primer=lambda **kwargs: "primer value",
  ...     message=lambda primer, **kwargs: primer
  ...   ),
  ... ).run().last_message
  'primer value'
  ```

* **action**: `Callable` for main-step of processing

  (kwargs: `out`, `primer`, `count`)

  ```
  >>> Pipeline(
  ...   Stage(
  ...     action=lambda out, **kwargs: out.update({"new_data": 0})
  ...   ),
  ... ).run().data
  {'new_data': 0}
  ```

* **export**: `Callable` that returns a dictionary of additional kwargs to be exported to the parent `Pipeline`; in the following `Stage`s, these kwargs are then available as if they were provided with the `Pipeline.run`-command

  (kwargs: `out`, `primer`, `count`)

  ```
  >>> Pipeline(
  ...   Stage(
  ...     export=lambda **kwargs: {"new_arg": 0}
  ...   ),
  ...   Stage(
  ...     message=lambda **kwargs:
  ...       "export successful" if "new_arg" in kwargs
  ...       else "missing new_arg"
  ...   ),
  ... ).run().last_message
  'export successful'
  ```
* **status**: `Callable` for generation of a `Stage`'s integer exit status

  (kwargs: `out`, `primer`, `count`)

* **message**: `Callable` for generation of a `Stage`'s exit message

  (kwargs: `out`, `primer`, `count`, `status`)
