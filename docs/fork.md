### Fork

[Documentation](../README.md#documentation)

A `Fork` represents a conditional in the execution of a `Pipeline`. It can be used to redirect the next `Pipeline`-target to a specific absolutely or relatively positioned `PipelineComponent`. Analogous to the `Stage`, a `Fork`'s `eval`-method is called with a numer of keyword arguments:
* all kwargs given to `Pipeline.run` are forwarded (note that this makes the following arguments reserved words in this context),
* **out** (a persistent data-object that is passed through the entire `Pipeline`; its initial value is generated by the `Pipeline`'s `initialize_output`),
* **count** (index of `Stage` in execution of `Pipeline`)
* **records** a list of previously generated `StageRecord`s (see `PipelineOutput` for more information)

#### Fork properties
A `Fork` takes a single `Callable` as argument. Based on the properties described above, a reference to a target `Stage` is returned. This reference can be made as one of several ways:
* integer; relative index in the `Pipeline`'s list of components
* string; a `PipelineComponent`'s string identifier in the context of a `Pipeline.run`
* `StageRef`; a more abstract form of reference, e.g. `First`, `Ç¸ext` (see `StageRef` for details)
* `None`; signal to (normally) exit `Pipeline.run`

#### Example
  ```
  >>> from data_plumber import Pipeline, Stage, Fork, Next
  >>> p = Pipeline(
        Stage(
          message=lambda **kwargs: "stage 1 executed"
        ),
        Fork(
          lambda **kwargs: Next if "arg" in kwargs else None
        ),
        Stage(
          message=lambda **kwargs: "stage 2 executed"
        ),
      )
  >>> p.run(arg=0).last_message
  'stage 2 executed'
  >>> p.run().last_message
  'stage 1 executed'
  ```